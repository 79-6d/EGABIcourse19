[
["index.html", "SCAR-EGABI Tools for Southern Ocean Spatial Analysis and Modelling 1 About this Technical stuff", " SCAR-EGABI Tools for Southern Ocean Spatial Analysis and Modelling Anton Van de Putte, Charlène Guillaumot, Grant Humphries, Huw Griffith, Ben Raymond 1 About this Blah blah Issues or suggestions about the content can be raised through the issue tracker (GitHub account required). Technical stuff This material has been written using bookdown and R. To build the book locally, clone the repo, open R and run the following lines: setwd(&quot;the/path/to/your/copy/of/the/repo&quot;) bookdown::render_book(&quot;index.Rmd&quot;) And view it with: browseURL(&quot;docs/index.html&quot;) "],
["overview.html", "2 Overview 2.1 Preparation 2.2 Taxonomy 2.3 Occurrences 2.4 Environmental data 2.5 Fit model 2.6 Predict from model 2.7 Other bits and pieces", " 2 Overview An example analysis that very briefly demonstrates some of the tasks that we’ll tackle during the workshop. 2.1 Preparation Make sure we have the packages we need from CRAN: pkgs &lt;- c(&quot;dplyr&quot;, &quot;ncdf4&quot;, &quot;raster&quot;, &quot;remotes&quot;, &quot;robis&quot;, &quot;worrms&quot;) pkgs &lt;- setdiff(pkgs, installed.packages()[, 1]) if (length(pkgs) &gt; 0) install.packages(pkgs) library(dplyr) And from GitHub: ## packages with required minimum version pkgs &lt;- c(&quot;SCAR/antanym&quot; = NA, &quot;AustralianAntarcticDivision/blueant&quot; = NA, &quot;AustralianAntarcticDivision/SOmap&quot; = &quot;0.3.0&quot;) for (pkg in names(pkgs)) { if (!basename(pkg) %in% installed.packages()[, 1] || (!is.na(pkgs[[pkg]]) &amp;&amp; packageVersion(basename(pkg)) &lt; pkgs[[pkg]])) { remotes::install_github(pkg) } } 2.2 Taxonomy library(worrms) my_species &lt;- &quot;Euphausia crystallorophias&quot; tax &lt;- wm_records_names(name = my_species) tax ## [[1]] ## # A tibble: 1 x 27 ## AphiaID url ## &lt;int&gt; &lt;chr&gt; ## 1 236216 http://www.marinespecies.org/aphia.php?p=taxdetails&amp;id=236216 ## scientificname authority status ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 Euphausia crystallorophias Holt &amp; Tattersall, 1906 accepted ## unacceptreason taxonRankID rank valid_AphiaID ## &lt;lgl&gt; &lt;int&gt; &lt;chr&gt; &lt;int&gt; ## 1 NA 220 Species 236216 ## valid_name valid_authority parentNameUsageID ## &lt;chr&gt; &lt;chr&gt; &lt;int&gt; ## 1 Euphausia crystallorophias Holt &amp; Tattersall, 1906 110673 ## kingdom phylum class order family genus ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 Animalia Arthropoda Malacostraca Euphausiacea Euphausiidae Euphausia ## citation ## &lt;chr&gt; ## 1 Siegel, V. (Ed) (2019). World Euphausiacea Database. Euphausia crystallo~ ## lsid isMarine isBrackish ## &lt;chr&gt; &lt;int&gt; &lt;lgl&gt; ## 1 urn:lsid:marinespecies.org:taxname:236216 1 NA ## isFreshwater isTerrestrial isExtinct match_type modified ## &lt;lgl&gt; &lt;lgl&gt; &lt;lgl&gt; &lt;chr&gt; &lt;chr&gt; ## 1 NA NA NA exact 2010-03-02T17:11:18.233Z ## the Aphia ID (taxonomic ID) of our species my_aphia_id &lt;- tax[[1]]$valid_AphiaID 2.3 Occurrences Get all data from the Antarctic Euphausiacea occurence data from “German Antarctic Marine Living Resources” (GAMLR) Expeditions data set: library(robis) ## Warning: package &#39;robis&#39; was built under R version 3.4.4 ##ds &lt;- dataset(taxonid = my_aphia_id) ##x &lt;- occurrence(datasetid = ds$id[6]) x &lt;- occurrence(datasetid = &quot;cb16377b-56a8-4d95-802d-4eec02466773&quot;) Plot the complete distribution of samples in black, and Euphausia crystallorophias in green: library(SOmap) SOmap_auto(x$decimalLongitude, x$decimalLatitude, input_lines = FALSE, pcol = &quot;black&quot;, pcex = 0.2) with(x %&gt;% dplyr::filter(aphiaID == my_aphia_id), SOplot(decimalLongitude, decimalLatitude, pch = 19, cex = 0.2, col = &quot;green&quot;)) Or as a polar stereo map: basemap &lt;- SOmap(trim = ceiling(max(x$decimalLatitude))+1, bathy_legend = FALSE) plot(basemap) SOplot(x$decimalLongitude, x$decimalLatitude, pch = 19, cex = 0.2, col = &quot;black&quot;) with(x %&gt;% dplyr::filter(aphiaID == my_aphia_id), SOplot(decimalLongitude, decimalLatitude, pch = 19, cex = 0.2, col = &quot;green&quot;)) Reorganise data into presence/absence by sampling site: xfit &lt;- x %&gt;% dplyr::rename(lon = &quot;decimalLongitude&quot;, lat = &quot;decimalLatitude&quot;) %&gt;% group_by(lon, lat) %&gt;% dplyr::summarize(present = any(my_aphia_id %in% aphiaID)) 2.4 Environmental data library(blueant) ## put the data into a temporary directory my_data_directory &lt;- tempdir() ## the data source we want data_source &lt;- sources_sdm(&quot;Southern Ocean marine environmental data&quot;) ## fetch the data status &lt;- bb_get(data_source, local_file_root = my_data_directory, verbose = TRUE) ## ## Thu Jul 11 09:53:32 2019 ## Synchronizing dataset: Southern Ocean marine environmental data ## Source URL https://data.aad.gov.au/eds/4742/download ## -------------------------------------------------------------------------------------------- ## ## this dataset path is: C:\\Users\\ben_ray\\AppData\\Local\\Temp\\RtmpWCYdnP/data.aad.gov.au/eds/4742 ## building file list ... done. ## downloading file 1 of 1: https://data.aad.gov.au/eds/4742/download ... done. ## decompressing: C:\\Users\\ben_ray\\AppData\\Local\\Temp\\RtmpWCYdnP/data.aad.gov.au/eds/4742/download.zip ... extracting 60 files into C:/Users/ben_ray/AppData/Local/Temp/RtmpWCYdnP/data.aad.gov.au/eds/4742 ... done. ## ## Thu Jul 11 09:53:40 2019 dataset synchronization complete: Southern Ocean marine environmental data nc_files &lt;- Filter(function(z) grepl(&quot;\\\\.nc$&quot;, z), status$files[[1]]$file) ## create a raster stack of all layers env_stack &lt;- stack(nc_files) ## the first few layers head(names(env_stack)) ## [1] &quot;chla_ampli_alltime_2005_2012&quot; &quot;chla_max_alltime_2005_2012&quot; ## [3] &quot;chla_mean_alltime_2005_2012&quot; &quot;chla_min_alltime_2005_2012&quot; ## [5] &quot;chla_sd_alltime_2005_2012&quot; &quot;depth&quot; Select just the depth and ice_cover_mean layers and extract their values at our sampling locations: env_stack &lt;- subset(env_stack, c(&quot;depth&quot;, &quot;ice_cover_mean&quot;)) temp &lt;- as.data.frame(raster::extract(env_stack, xfit[, c(&quot;lon&quot;, &quot;lat&quot;)])) xfit &lt;- bind_cols(xfit, temp) head(xfit) ## # A tibble: 6 x 5 ## # Groups: lon [5] ## lon lat present depth ice_cover_mean ## &lt;dbl&gt; &lt;dbl&gt; &lt;lgl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 -122. -73.2 TRUE -660. 0.730 ## 2 -122. -73.2 FALSE -660. 0.730 ## 3 -121. -72.6 FALSE -1409. 0.747 ## 4 -121. -72.6 FALSE -1409. 0.747 ## 5 -121. -72.1 FALSE -1764. 0.726 ## 6 -121. -72.1 FALSE -1764. 0.726 2.5 Fit model We have presence/absence data, so we’ll fit a simple binomial model. The probability of presence of Euphausia crystallorophias is fitted as a smooth function of depth and mean sea ice cover: library(mgcv) ## Warning: package &#39;mgcv&#39; was built under R version 3.4.4 fit &lt;- gam(present ~ s(depth) + s(ice_cover_mean), family = binomial, data = xfit) summary(fit) ## ## Family: binomial ## Link function: logit ## ## Formula: ## present ~ s(depth) + s(ice_cover_mean) ## ## Parametric coefficients: ## Estimate Std. Error z value Pr(&gt;|z|) ## (Intercept) -4.3728 0.3402 -12.85 &lt;2e-16 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Approximate significance of smooth terms: ## edf Ref.df Chi.sq p-value ## s(depth) 3.029 3.792 42.03 2.33e-08 *** ## s(ice_cover_mean) 8.501 8.923 206.88 &lt; 2e-16 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## R-sq.(adj) = 0.265 Deviance explained = 32.5% ## UBRE = -0.64176 Scale est. = 1 n = 2390 The fits to depth and ice cover: plot(fit, pages = 1, shade = TRUE) 2.6 Predict from model xpred &lt;- expand.grid(lon = seq(from = floor(min(xfit$lon)), to = ceiling(max(xfit$lon)), by = 0.25), lat = seq(from = floor(min(xfit$lat)), to = ceiling(max(xfit$lat)), by = 0.25)) xpred &lt;- bind_cols(as.data.frame(xpred), as.data.frame(raster::extract(env_stack, xpred[, c(&quot;lon&quot;, &quot;lat&quot;)]))) xpred$predicted &lt;- predict(fit, newdata = xpred, type = &quot;response&quot;) ## create raster pr &lt;- rasterFromXYZ(xpred[, c(&quot;lon&quot;, &quot;lat&quot;, &quot;predicted&quot;)]) projection(pr) &lt;- &quot;+proj=longlat +datum=WGS84&quot; my_cmap &lt;- if (getRversion() &gt;= &quot;3.6&quot;) hcl.colors(21, &quot;Geyser&quot;) else topo.colors(21) Plot it: p &lt;- SOmap_auto(x = pr, bathy = pr) p$bathy_palette &lt;- my_cmap p plot(basemap) SOplot(pr, col = my_cmap) 2.7 Other bits and pieces 2.7.1 Place names library(antanym) ## get full SCAR gazetteer data xn &lt;- an_read(cache = &quot;session&quot;, sp = TRUE) ## reduce to one name per feature xn &lt;- an_preferred(xn, origin = &quot;United Kingdom&quot;) ## ask for suggestions in our region to show on our map xns &lt;- an_suggest(xn, map_scale = 20e6, map_extent = extent(pr)) ## transform to our map projection, convert to data frame, take the top 10 xns &lt;- as_tibble(SOproj(xns, target = basemap$projection)) %&gt;% head(10) Add them to the map: plot(basemap) SOplot(pr, col = my_cmap) with(xns, points(x = longitude, y = latitude, pch = 16, cex = 0.4)) with(xns, text(x = longitude, y = latitude, labels = place_name, cex = 0.75, pos = 2 + 2*(seq_len(nrow(xns)) %% 2))) "],
["introduction-to-r-and-the-tidyverse.html", "3 Introduction to R and the tidyverse 3.1 R 3.2 The tidyverse", " 3 Introduction to R and the tidyverse 3.1 R See Getting Started in R by Saghir Bashir. 3.2 The tidyverse "],
["biological-data.html", "4 Biological data", " 4 Biological data "],
["mapping.html", "5 Mapping 5.1 SOmap 5.2 Supporting data for maps", " 5 Mapping 5.1 SOmap Blurb. intended to provide an easy way to get SO maps primarily polar stereo projection, though SOmap_auto is not necessarily so base/raster/sp gg SOmap won’t necessarily get you exactly the map you want. But it should hopefully get you close enough that you can make modifications to suit your exact purposes. 5.1.1 Circumpolar maps A basic circumpolar map in polar stereographic projection: library(SOmap) SOmap() SOmanagement() provides a number of contextual layers such as MPA boundaries and management zones. SOmap(trim = -40) ## plot to 40S ## add the exclusive economic zones management layer SOmanagement(eez = TRUE) 5.1.1.1 Adding points ## some longitude/latitude data library(sp) my_points_ll &lt;- data.frame(lon = seq(0, 350, by = 10), lat = -55, z = runif(36)) coordinates(my_points_ll) &lt;- c(&quot;lon&quot;, &quot;lat&quot;) projection(my_points_ll) &lt;- &quot;+proj=longlat +datum=WGS84&quot; This needs to be reprojected to match our map before plotting. The SOproj function does this: ## reproject to our SOmap projection my_points &lt;- SOproj(my_points_ll) ## and plot SOmap() plot(my_points, col = &quot;blue&quot;, add = TRUE) Or use SOplot to reproject and plot in one step: SOmap() SOplot(my_points_ll, col = &quot;blue&quot;) 5.1.1.2 Adding raster layers 5.1.1.3 Modifying the SOmap object Calls to SOmap(), SOmanagement(), SOmap_auto() return an object of class SOmap, SOmap_management, or SOmap_auto. These objects contain all of the data and plotting instructions required to draw the map. Calling print() or plot() on one of these objects will cause that code to be executed, and the object to be drawn in the current graphics device. Hence, calling SOmap() directly without assigning the result to a variable will make it appear in the graphics device, because the returned object is being printed to the console (and thus triggering the print method). But you can also assign the result to a variable, e.g. myplot &lt;- SOmap() and then explicitly plot the object with plot(myplot). The advantage of this is that you can potentially manipulate the myplot object to make changes to the map before plotting it. Note, this is likely to be fragile. Proceed at your own risk! mymap &lt;- SOmap() names(mymap) ## [1] &quot;projection&quot; &quot;target&quot; &quot;straight&quot; &quot;trim&quot; ## [5] &quot;bathy&quot; &quot;box&quot; &quot;plot_sequence&quot; &quot;coastline&quot; ## [9] &quot;ice&quot; &quot;bathy_legend&quot; &quot;border&quot; The object contains a plot_sequence component, which defines the order in which each part of the plot is drawn. The other components of the object contain the code required to draw each part. Take e.g. the ice component (this is the ice shelves, glacier tongues, etc). This is a list (in this case with only one element). Each element of the list specifies a function to run along with arguments to pass to it: str(mymap$ice) ## List of 1 ## $ :List of 2 ## ..$ plotfun : chr &quot;plot&quot; ## ..$ plotargs:List of 4 ## .. ..$ x :sfc_POLYGON of length 354; first list element: List of 1 ## .. .. ..$ : num [1:5, 1:2] 1022981 1026000 1021994 1021935 1022981 ... ## .. .. ..- attr(*, &quot;class&quot;)= chr [1:3] &quot;XY&quot; &quot;POLYGON&quot; &quot;sfg&quot; ## .. ..$ col : logi NA ## .. ..$ border: chr &quot;black&quot; ## .. ..$ add : logi TRUE ## ..- attr(*, &quot;class&quot;)= chr &quot;SO_plotter&quot; We can modify the function and/or its arguments: mymap$ice[[1]]$plotargs$col &lt;- &quot;green&quot; plot(mymap) 5.1.2 Non-circumpolar maps via SOmap_auto note that this is not always going to guess the best projection/extent best viewed as a starting point for your own maps 5.1.3 Plotting via ggplot2 The SOmap and SOmap_auto functions do their plotting using base graphics. If you are more comfortable working with ggplot2, this is also possible. convert SOmap object to ggplot format using SOgg() as with other SOmap functions, this returns an object that contains all of the information needed to generate the map. Printing or plotting this object will cause it to construct a ggplot object. Printing or plotting that object will cause it to be drawn to the graphics device, just like any other ggplot object. myplot &lt;- SOmap() myplotgg &lt;- SOgg(myplot) ## creates a SOmap_gg object class(myplotgg) ## [1] &quot;SOmap_gg&quot; my_ggplot &lt;- plot(myplotgg) ## creates a ggplot object class(my_ggplot) ## [1] &quot;gg&quot; &quot;ggplot&quot; plot(my_ggplot) ## plot it Or in one step (this will cause myplot to be converted to SOmap’s internal gg format, then a ggplot object constructed from that, then that object will be plotted): SOgg(myplot) 5.1.3.1 Modifying these maps We can modify these maps at two levels. 5.1.3.1.1 Modifying the SOmap_gg object SOmap_gg objects are similar in structure to SOmap objects: names(myplotgg) ## [1] &quot;projection&quot; &quot;target&quot; &quot;straight&quot; &quot;trim&quot; ## [5] &quot;init&quot; &quot;bathy&quot; &quot;coord&quot; &quot;plot_sequence&quot; ## [9] &quot;scale_fill&quot; &quot;bathy_legend&quot; &quot;coastline&quot; &quot;ice&quot; ## [13] &quot;axis_labels&quot; &quot;theme&quot; &quot;border&quot; Instead of base plotting functions, SOmap_gg objects use ggplot2 function calls, e.g.: myplotgg$ice[[1]]$plotfun ## [1] &quot;ggplot2::geom_sf&quot; We can modify these function and/or arguments in a similar manner to SOmap objects. myplotgg$ice[[1]]$plotargs$fill &lt;- &quot;green&quot; plot(myplotgg) 5.1.3.1.2 Modifying the ggplot object. Remember that printing or plotting a SOmap_gg object produces a ggplot object. This can be modified by adding e.g. layers or themes just like a normal ggplot. Remember to load the ggplot2 library now that we are using ggplot2 functions directly. library(ggplot2) my_ggplot + geom_point(data = as.data.frame(my_points), aes(lon, lat, colour = z), size = 3) + scale_colour_distiller(palette = &quot;Spectral&quot;) 5.2 Supporting data for maps When constructing maps, we commonly want to show features like oceanographic fronts, ice extent, coastline, place names, and MPA boundaries. There are a few sources of such data: some layers are bundled into SOmap, see the SOmap::SOmap_data object antanym provides access to the SCAR Composite Gazetteer of place names the quantarcticR package provides access to Quantarctica data layers. 5.2.1 quantarcticR Note, this package is still in development. Install if needed: remotes::install_github(&quot;SCAR-sandpit/quantarcticR&quot;) Example usage: library(quantarcticR) ds &lt;- qa_datasets() ## all available layers kable(head(ds)) layername main_file type cached download_size Overview place names C:_ray8PMm/quantarcticR-cache/Miscellaneous/OverviewPlaceNames/OverviewPlaceNames.shp shapefile FALSE 19.74K COMNAP listed facilities C:_ray8PMm/quantarcticR-cache/Miscellaneous/Stations/COMNAP_Antarctic_Facilities.shp shapefile FALSE 691.92K Subantarctic stations C:_ray8PMm/quantarcticR-cache/Miscellaneous/Stations/Sub-antarctic_Stations.shp shapefile FALSE 691.92K SCAR Composite gazetteer C:_ray8PMm/quantarcticR-cache/Miscellaneous/SCAR_CompositeGazetteer/SCAR_CompositeGazetteer.shp shapefile FALSE 329.05M IBO-IOC GEBCO Features (point) C:_ray8PMm/quantarcticR-cache/Miscellaneous/IHO-IOC_GEBCO_UnderseaFeatureNames/GEBCO_point.shp shapefile FALSE 1.25M IBO-IOC GEBCO Features (multipoint) C:_ray8PMm/quantarcticR-cache/Miscellaneous/IHO-IOC_GEBCO_UnderseaFeatureNames/GEBCO_multipoint.shp shapefile FALSE 1.25M ## more info about a particular layer my_layer &lt;- qa_dataset(&quot;Median sea ice extent 1981-2010&quot;) my_layer ## # A tibble: 1 x 11 ## layername ## &lt;chr&gt; ## 1 Median sea ice extent 1981-2010 ## datasource ## &lt;chr&gt; ## 1 SeaIce/Median Ice Extents/Median_SeaIce_Extents_1981-2010.shp ## layer_attributes srs_attributes provider ## &lt;list&gt; &lt;list&gt; &lt;chr&gt; ## 1 &lt;NULL&gt; &lt;tibble [1 x 4]&gt; ogr ## abstract ## &lt;chr&gt; ## 1 &quot;Monthly median sea ice extents for the period 1981-2010.\\n\\nFetterer, F~ ## extent type download_size ## &lt;list&gt; &lt;chr&gt; &lt;fs::bytes&gt; ## 1 &lt;NULL&gt; shapefile 131K ## main_file ## &lt;chr&gt; ## 1 &quot;C:\\\\Users\\\\ben_ray\\\\AppData\\\\Local\\\\Temp\\\\Rtmpkj8PMm/quantarcticR-cache~ ## bb_source$id ## &lt;chr&gt; ## 1 Quantarctica: Median sea ice extent 1981-2010 ## $name $description ## &lt;chr&gt; &lt;chr&gt; ## 1 Median sea ice extent 1981-2010 Quantarctica data ## $doc_url $source_url ## &lt;chr&gt; &lt;list&gt; ## 1 http://quantarctica.npolar.no/ &lt;chr [1]&gt; ## $citation ## &lt;chr&gt; ## 1 Matsuoka, K., Skoglund, A., &amp; Roth, G. (2018). Quantarctica Median sea i~ ## $license $comment $method $postprocess ## &lt;chr&gt; &lt;chr&gt; &lt;list&gt; &lt;list&gt; ## 1 CC-BY 4.0 International &lt;NA&gt; &lt;list [5]&gt; &lt;list [0]&gt; ## $authentication_note $user $password $access_function $data_group ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; ## $collection_size ## &lt;lgl&gt; ## 1 NA ## fetch the actual data for that layer layer_data &lt;- qa_get(my_layer) ## plot it plot(layer_data[layer_data$MONTH == &quot;October&quot;, ]) ## or add to a SOmap SOmap(trim = -50, border_width = 0.5) SOplot(layer_data[layer_data$MONTH == &quot;October&quot;, ], col = &quot;red&quot;) 5.2.2 antanym See the overview article. "],
["species-distribution-modelling.html", "6 Species distribution modelling 6.1 Introduction and review 6.2 Methods 6.3 Evaluation", " 6 Species distribution modelling 6.1 Introduction and review 6.2 Methods 6.3 Evaluation 6.3.1 Other modelling approaches "],
["other-r-resources-for-southern-oceanantarctic-use.html", "7 Other R resources for Southern Ocean/Antarctic use 7.1 Diet data: sohungry 7.2 Allometric equations: solong", " 7 Other R resources for Southern Ocean/Antarctic use 7.1 Diet data: sohungry 7.2 Allometric equations: solong "]
]
