# Mapping

## SOmap

```{r somapcheck, echo = FALSE}
if (packageVersion("SOmap") < 0.5)
  stop("This bookdown code currently requires the development version of SOmap.\nInstall with remotes::install_github(\"AustralianAntarcticDivision/SOmap\", ref = \"dev-0.5\")")
```

The `SOmap` package is intended to provide an easy way to produce nice-looking maps of Antarctica and the Southern Ocean. It is primarily focused on maps in polar stereographic projection (although the `SOmap_auto` function extends this to other projections). `SOmap` won't necessarily get you exactly the map you want. But if it doesn't, it should hopefully get you close enough that you can make modifications to suit your exact purposes.

Please bear in mind that `SOmap` is still in development, and so its functionality (function parameters and/or behaviour) may change.

By default, `SOmap` works with base graphics (and associated functionality from packages such as `raster` and `sp`). It is also possible to work with `ggplot2`-based graphics, as described below.


### Circumpolar maps

A basic circumpolar map in polar stereographic projection:

```{r somap1}
library(SOmap)
SOmap()
```

`SOmanagement()` provides a number of contextual layers such as MPA boundaries and management zones.

```{r somap2}
SOmap(trim = -40) ## plot to 40S
## add the exclusive economic zones management layer
SOmanagement(eez = TRUE)
```

#### Adding points

```{r somap_pts1}
## some longitude/latitude data
library(sp)
my_points_ll <- data.frame(lon = seq(0, 350, by = 10), lat = -55, z = runif(36))
coordinates(my_points_ll) <- c("lon", "lat")
projection(my_points_ll) <- "+proj=longlat +datum=WGS84"
```

This needs to be reprojected to match our map before plotting. The `SOproj` function does this:

```{r somap_pts2}
## reproject to our SOmap projection
my_points <- SOproj(my_points_ll)
## and plot
SOmap()
plot(my_points, col = "blue", add = TRUE)
```

Or use `SOplot` to reproject and plot in one step:

```{r somap_pts3}
SOmap()
SOplot(my_points_ll, col = "blue")
```

#### Adding raster layers

First let's construct some artificial raster data (in longitude-latitude space) for demonstration purposes:

```{r somap_raster1, message = FALSE, warning = FALSE}
library(raster)
temp <- as.data.frame(expand.grid(lon = seq(100, 140, by = 0.25), lat = seq(-65, -45, by = 0.1)))
temp$val <- sqrt((temp$lon - 120)^2/3 + (temp$lat - -40)^2/5)
## create raster object
xr <- rasterFromXYZ(temp)
projection(xr) <- "+proj=longlat +datum=WGS84"
```

`SOplot` will reproject and plot this for us:

```{r somap_raster2}
SOmap()
SOplot(xr)
```

The legend is out of character with the rest of the map. We can use `SOleg` to fix that:

```{r somap_raster3}
## colour map to use
my_cmap <- colorRampPalette(c("#4D4140", "#596F7E", "#168B98",
                                   "#ED5B67", "#E27766", "#DAAD50", "#EAC3A6"))(51)

## draw the base map
SOmap()

## add our raster
SOplot(xr, legend = FALSE, col = my_cmap)

## add the legend
SOleg(xr, position = "topright", col = my_cmap, ticks = 6,
      type = "continuous", label = "My variable")
```

OK, well that worked but clearly the labels need tidying up. We can do that, but we have to be careful to make sure that the colour range of the legend matches that of the plotted raster.

```{r somap_raster4}
## draw the base map
SOmap()

## add our raster, controlling the colour range to span the values 0 to 30
SOplot(xr, legend = FALSE, col = my_cmap,
       breaks = seq(0, 30, length.out = length(my_cmap) + 1))

## add the legend, again controlling the colour range
SOleg(position = "topright", col = my_cmap,
      breaks = seq(0, 30, length.out = 7),
      type = "continuous", label = "My variable")
```


Multiple rasters:

```{r somap_raster5}
xr2 <- shift(xr, x = -70) ## offset in longitude
SOmap()
SOplot(xr, legend = FALSE, col = my_cmap)
SOplot(xr2, legend = FALSE, col = my_cmap)
```




#### Modifying maps

Calls to `SOmap()`, `SOmanagement()`, `SOmap_auto()` return an object of class `SOmap`, `SOmap_management`, or `SOmap_auto`. These objects contain all of the data and plotting instructions required to draw the map. Calling `print()` or `plot()` on one of these objects will cause that code to be executed, and the object to be drawn in the current graphics device. Hence, calling `SOmap()` directly *without* assigning the result to a variable will make it appear in the graphics device, because the returned object is being printed to the console (and thus triggering the `print` method). But you can also assign the result to a variable, e.g. `myplot <- SOmap()` and then explicitly plot the object with `plot(myplot)`. The advantage of this is that you can potentially manipulate the `myplot` object to make changes to the map before plotting it.

Note, this is likely to be fragile. Proceed at your own risk!

```{r somap2a}
mymap <- SOmap()
names(mymap)
```

The object contains a `plot_sequence` component, which defines the order in which each part of the plot is drawn. The other components of the object contain the code required to draw each part. Take e.g. the ice component (this is the ice shelves, glacier tongues, etc). This is a list (in this case with only one element). Each element of the list specifies a function to run along with arguments to pass to it:

```{r somap2b}
str(mymap$ice)
```

We can modify the function and/or its arguments:

```{r somap2c}
mymap$ice[[1]]$plotargs$col <- "green"
```

```{r somap2d}
plot(mymap)
```

We can remove entire components:
```{r somap2e}
temp <- mymap
temp$coastline <- NULL
temp$ice <- NULL
plot(temp)
```

But note that some elements are required (in particular, the bathymetry layer can't currently be removed because the code that draws this is also the code that creates the plot). This code would fail (not run here):

```{r somap2f, eval = FALSE}
temp <- mymap
temp$bathy <- NULL
plot(temp)
```


### Non-circumpolar maps

The `SOmap_auto` function will take your input data and make a guess at an appropriate projection and extent to use. Note that this is not always going to guess the *best* projection and extent, so you should view it as a starting point from which you can generate a map to your exact requirements.

Use the elephant seal track data bundled with the package:

```{r soauto1}
ellie <- SOmap_data$mirounga_leonina

## construct and plot the map
SOmap_auto(ellie$lon, ellie$lat)
```

Just a blank map to which you could add other things:
```{r soauto2}
SOmap_auto(ellie$lon, ellie$lat, input_points = FALSE, input_lines = FALSE)
```

You can pass a raster as input data, but note that it won't plot the raster (it uses its extent to infer an appropriate extent for the map):
```{r soauto3}
SOmap_auto(xr)
```

But we can add the raster if we wish:
```{r soauto4}
SOmap_auto(xr)
SOplot(xr, col = my_cmap)
```

We can force a particular projection:

```{r soauto5}
SOmap_auto(xr, target = "laea", centre_lon = 147, centre_lat = -42)
SOplot(xr, col = my_cmap)
```

Same but by supplying a full proj4 string to `target`:

```{r soauto6}
SOmap_auto(xr, target = "+proj=laea +lat_0=-42 +lon_0=147")
SOplot(xr, col = my_cmap)
```

See [the SOmap_auto vignette](https://australianantarcticdivision.github.io/SOmap/articles/many-automap-examples.html) for more examples.


### Plotting via ggplot2

The `SOmap` and `SOmap_auto` functions do their plotting using base graphics. If you are more comfortable working with `ggplot2`, this is also possible.

- convert SOmap object to ggplot format using `SOgg()`
- as with other `SOmap` functions, this returns an object that contains all of the information needed to generate the map. Printing or plotting this object will cause it to construct a `ggplot` object. Printing or plotting *that* object will cause it to be drawn to the graphics device, just like any other `ggplot` object.

```{r somap3}
myplot <- SOmap()

myplotgg <- SOgg(myplot) ## creates a SOmap_gg object

class(myplotgg)

my_ggplot <- plot(myplotgg) ## creates a ggplot object

class(my_ggplot)

plot(my_ggplot) ## plot it
```

Or in one step (this will cause myplot to be converted to SOmap's internal gg format, then a ggplot object constructed from that, then that object will be plotted):

```{r somap4}
SOgg(myplot)
```

#### Modifying these maps

We can modify these maps at two levels.

##### Modifying the `SOmap_gg` object

`SOmap_gg` objects are similar in structure to `SOmap` objects:

```{r somap5}
names(myplotgg)
```

Instead of base plotting functions, `SOmap_gg` objects use `ggplot2` function calls, e.g.:

```{r somap5a}
myplotgg$ice[[1]]$plotfun
```

We can modify these function and/or arguments in a similar manner to `SOmap` objects.

```{r somap5b}
myplotgg$ice[[1]]$plotargs$fill <- "green"
```

```{r somap5c}
plot(myplotgg)
```

Or remove the bathymetric raster layer:

```{r somap5d}
temp <- myplotgg
temp$bathy <- NULL
temp$bathy_legend <- NULL
plot(temp)
```


```{r somaphidden, echo = FALSE, eval = FALSE}
## Adding multiple rasters gets tricky (if they require separate colour scales), because `ggplot2` is only designed to work with a single colour scale per geometry type. However, the `ggnewscale` package can help here:

## these functions don't exist in base R < 3.5 but are used by ggnewscale
isFALSE <- function (x) is.logical(x) && length(x) == 1L && !is.na(x) && !x
isTRUE <- function (x) is.logical(x) && length(x) == 1L && !is.na(x) && x
```

```{r somap5e, include = FALSE, eval = FALSE}
library(ggnewscale)
plot(myplotgg) + new_scale_fill() +
  geom_raster(data = as.data.frame(xr, xy = TRUE), aes(x = x, y = y, fill = val), inherit.aes = FALSE) +
  scale_fill_gradientn(colors = my_cmap, na.value = NA, name = "My variable")
```



##### Modifying the `ggplot` object.

Remember that printing or plotting a `SOmap_gg` object produces a `ggplot` object. This can be modified by adding e.g. layers or themes just like a normal `ggplot`. Remember to load the `ggplot2` library now that we are using `ggplot2` functions directly.

```{r somap6, message = FALSE, warning = FALSE}
library(ggplot2)

my_ggplot + geom_point(data = as.data.frame(my_points), aes(lon, lat, colour = z), size = 3) +
  scale_colour_distiller(palette = "Spectral")
```

## Supporting data for maps

When constructing maps, we commonly want to show features like oceanographic fronts, ice extent, coastline, place names, and MPA boundaries. There are a few sources of such data:

- some layers are bundled into `SOmap`, see the `SOmap::SOmap_data` object
- `antanym` provides access to the SCAR Composite Gazetteer of place names
- the `quantarcticR` package provides access to [Quantarctica](http://quantarctica.npolar.no/) data layers.

### quantarcticR

Note, this package is still in development, so the usage as shown here might change in later versions. Install if needed:

```{r eval = FALSE}
remotes::install_github("SCAR-sandpit/quantarcticR")
```

Example usage:

```{r qR1}
library(quantarcticR)
ds <- qa_datasets() ## all available layers
head(ds)

## more info about a particular layer
my_layer <- qa_dataset("Median sea ice extent 1981-2010")
my_layer

## fetch the actual data for that layer
layer_data <- qa_get(my_layer)

## plot it
plot(layer_data[layer_data$MONTH == "October", ])

## or add to a SOmap
SOmap(trim = -50, border_width = 0.5)
SOplot(layer_data[layer_data$MONTH == "October", ], col = "red")

```

### antanym

See the [overview](overview.html) article.
